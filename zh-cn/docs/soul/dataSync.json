{
  "filename": "dataSync.md",
  "__html": "<h2>说明</h2>\n<ul>\n<li>本篇主要讲解数据库同步的三种方式，以及原理</li>\n</ul>\n<h1>前言</h1>\n<p>网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，<code>Soul</code> 网关又是如何支持动态配置的呢?</p>\n<p>使用过 <code>Soul</code> 的同学都知道，<code>Soul</code> 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 <code>Soul</code> 网关过程中，用户也反馈了不少问题</p>\n<ul>\n<li>依赖 <code>zookeeper</code>，这让使用 <code>etcd</code>、<code>consul</code>、<code>nacos</code> 注册中心的用户很是困扰</li>\n<li>依赖 <code>redis</code>、<code>influxdb</code>，我还没有使用限流插件、监控插件，为什么需要这些</li>\n</ul>\n<p>因此，我们对 <code>Soul</code> 进行了局部重构，历时两个月的版本迭代，我们发布了 <code>2.0</code> 版本</p>\n<ul>\n<li>数据同步方式移除了对 <code>zookeeper</code> 的强依赖，新增 <code>http 长轮询</code> 以及 <code>websocket</code></li>\n<li>限流插件与监控插件实现真正的动态配置，由之前的 <code>yml</code> 配置，改为 <code>admin</code> 后台用户动态配置</li>\n</ul>\n<h5>1.可能有人会问我，配置同步为什么不使用配置中心呢？</h5>\n<p>答：首先，引入配置中心，会增加很多额外的成本，不光是运维，而且会让 <code>Soul</code> 变得很重；另外，使用配置中心，数据格式不可控，不便于 <code>soul-admin</code> 进行配置管理。</p>\n<h5>2.可能还有人会问？动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？</h5>\n<p>答：soul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。</p>\n<h1>原理分析</h1>\n<p>先来张高清无码图，下图展示了 <code>Soul</code> 数据同步的流程，<code>Soul</code> 网关在启动时，会从从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 <code>Soul</code> 网关，具体是 <code>push</code> 模式，还是 <code>pull</code> 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。\n<img src=\"https://bestkobe.gitee.io/images/soul/soul-config-processor.png?_t=201908032316\" alt=\"Soul数据同步流程图\"></p>\n<p>在 <code>1.x</code> 版本中，配置服务依赖 <code>zookeeper</code> 实现，管理后台将变更信息 <code>push</code> 给网关。而 <code>2.x</code> 版本支持 <code>webosocket</code>、<code>http</code>、<code>zookeeper</code>，通过 <code>soul.sync.strategy</code> 指定对应的同步策略，默认使用 <code>http</code> 长轮询同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，<code>soul-web</code> 和 <code>soul-admin</code> 必须使用相同的同步机制。</p>\n<p>如下图所示，<code>soul-admin</code> 在用户发生配置变更之后，会通过 <code>EventPublisher</code> 发出配置变更通知，由 <code>EventDispatcher</code> 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器</p>\n<ul>\n<li>如果是 <code>websocket</code> 同步策略，则将变更后的数据主动推送给 <code>soul-web</code>，并且在网关层，会有对应的 <code>WebsocketCacheHandler</code> 处理器处理来处 <code>admin</code> 的数据推送</li>\n<li>如果是 <code>zookeeper</code> 同步策略，将变更数据更新到 <code>zookeeper</code>，而 <code>ZookeeperSyncCache</code> 会监听到 <code>zookeeper</code> 的数据变更，并予以处理</li>\n<li>如果是 <code>http</code> 同步策略，<code>soul-web</code> 主动发起长轮询请求，默认有 90s 超时时间，如果 <code>soul-admin</code> 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求\n<img src=\"https://bestkobe.gitee.io/images/soul/config-strage-processor.png?_t=201908032339\" alt=\"Soul配置同步策略流程图\"></li>\n</ul>\n<h2>zookeeper同步</h2>\n<p>基于 zookeeper 的同步原理很简单，主要是依赖 <code>zookeeper</code> 的 watch 机制，<code>soul-web</code> 会监听配置的节点，<code>soul-admin</code> 在启动的时候，会将数据全量写入 <code>zookeeper</code>，后续数据发生变更时，会增量更新 <code>zookeeper</code> 的节点，与此同时，<code>soul-web</code> 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。</p>\n<p><img src=\"https://yu199195.github.io/images/soul/soul-zookeeper.png\" alt=\"zookeeper节点设计\"></p>\n<p><code>soul</code> 将配置信息写到zookeeper节点，是通过精细设计的。</p>\n<h2>websocket同步</h2>\n<p><code>websocket</code> 和 <code>zookeeper</code> 机制有点类似，将网关与 <code>admin</code> 建立好 <code>websocket</code> 连接时，<code>admin</code> 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 <code>websocket</code> 主动推送给 <code>soul-web</code></p>\n<p>使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。<code>soul</code>使用<code>java-websocket</code> 这个第三方库来进行<code>websocket</code>连接。</p>\n<pre><code>public class WebsocketSyncCache extends WebsocketCacheHandler {\n    /**\n     * The Client.\n     */\n    private WebSocketClient client;\n\n    public WebsocketSyncCache(final SoulConfig.WebsocketConfig websocketConfig) {\n        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1,\n                SoulThreadFactory.create(&quot;websocket-connect&quot;, true));\n         client = new WebSocketClient(new URI(websocketConfig.getUrl())) {\n                @Override\n                public void onOpen(final ServerHandshake serverHandshake) {\n                  //....\n                }\n                @Override\n                public void onMessage(final String result) {\n                  //....\n                }    \n            };\n        //进行连接\n        client.connectBlocking();\n        //使用调度线程池进行断线重连，30秒进行一次\n        executor.scheduleAtFixedRate(() -&gt; {\n            if (client != null &amp;&amp; client.isClosed()) {\n                    client.reconnectBlocking();\n            }\n        }, 10, 30, TimeUnit.SECONDS);\n    }\n</code></pre>\n<h2>http长轮询</h2>\n<p>zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 <code>Apollo</code>、<code>Nacos</code> 的设计思想，取其精华，自己实现了 <code>http</code> 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！</p>\n<p><img src=\"https://bestkobe.gitee.io/images/soul/http-long-polling.png?_t=201908032339\" alt=\"http长轮询\"></p>\n<p>http 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多会等待 90s，这样便于 admin 配置服务及时响应变更数据，从而实现准实时推送。</p>\n<p>http 请求到达 sou-admin 之后，并非立马响应数据，而是利用 Servlet3.0 的异步机制，异步响应数据。首先，将长轮询请求任务 <code>LongPollingClient</code> 扔到 <code>BlocingQueue</code> 中，并且开启调度任务，60s 后执行，这样做的目的是 60s 后将该长轮询请求移除队列，即便是这段时间内没有发生配置数据变更。因为即便是没有配置变更，也得让网关知道，总不能让其干等吧，而且网关请求配置服务时，也有 90s 的超时时间。</p>\n<pre><code>public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {\n    // 因为soul-web可能未收到某个配置变更的通知，因此MD5值可能不一致，则立即响应\n    List&lt;ConfigGroupEnum&gt; changedGroup = compareMD5(request);\n    String clientIp = getRemoteIp(request);\n    if (CollectionUtils.isNotEmpty(changedGroup)) {\n        this.generateResponse(response, changedGroup);\n        return;\n    }\n\n    // Servlet3.0异步响应http请求\n    final AsyncContext asyncContext = request.startAsync();\n    asyncContext.setTimeout(0L);\n    scheduler.execute(new LongPollingClient(asyncContext, clientIp, 60));\n}\n    \nclass LongPollingClient implements Runnable {\n    LongPollingClient(final AsyncContext ac, final String ip, final long timeoutTime) {\n        // 省略......\n    }\n    @Override\n    public void run() {\n        // 加入定时任务，如果60s之内没有配置变更，则60s后执行，响应http请求\n        this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {\n            // clients是阻塞队列，保存了来自soul-web的请求信息\n            clients.remove(LongPollingClient.this);\n            List&lt;ConfigGroupEnum&gt; changedGroups = HttpLongPollingDataChangedListener.compareMD5((HttpServletRequest) asyncContext.getRequest());\n            sendResponse(changedGroups);\n        }, timeoutTime, TimeUnit.MILLISECONDS);\n        // \n        clients.add(this);\n    }\n}\n</code></pre>\n<p>如果这段时间内，管理员变更了配置数据，此时，会挨个移除队列中的长轮询请求，并响应数据，告知是哪个 Group 的数据发生了变更（我们将插件、规则、流量配置、用户配置数据分成不同的组）。网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。有人会问，为什么不是直接将变更的数据写出？我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</p>\n<pre><code>// soul-admin发生了配置变更，挨个将队列中的请求移除，并予以响应\nclass DataChangeTask implements Runnable {\n    DataChangeTask(final ConfigGroupEnum groupKey) {\n        this.groupKey = groupKey;\n    }\n    @Override\n    public void run() {\n        try {\n            for (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext(); ) {\n                LongPollingClient client = iter.next();\n                iter.remove();\n                client.sendResponse(Collections.singletonList(groupKey));\n            }\n        } catch (Throwable e) {\n            LOGGER.error(&quot;data change error.&quot;, e);\n        }\n    }\n}\n</code></pre>\n<p>当 <code>soul-web</code> 网关层接收到 http 响应信息之后，拉取变更信息（如果有变更的话），然后再次请求 <code>soul-admin</code> 的配置服务，如此反复循环。</p>\n<h2>仓库地址</h2>\n<p>github: <a href=\"https://github.com/Dromara/soul\">https://github.com/Dromara/soul</a></p>\n<p>gitee:  <a href=\"https://gitee.com/shuaiqiyu/soul\">https://gitee.com/shuaiqiyu/soul</a></p>\n<p>项目主页上还有视频教程，有需要的朋友可以去观看。</p>\n<h2>最后</h2>\n<p>此文介绍了<code>soul</code>作为一个高可用的微服务网关，为了优化响应速度，在对配置规则选择器器数据进行本地缓存的三种方式，学了此文，我相信你对现在比较流行的配置中心有了一定的了解，看他们的代码也许会变得容易，我相信你也可以自己写一个分布式配置中心出来。3.0版本已经在规划中，肯定会给大家带来惊喜。</p>\n",
  "link": "\\zh-cn\\docs\\soul\\dataSync.html",
  "meta": {
    "title": "数据同步设计",
    "keywords": "soul",
    "description": "数据同步设计"
  }
}