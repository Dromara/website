<!DOCTYPE html>
<html lang="zh">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="dromara.org" />
	<meta name="description" content="dromara.org" />
	<!-- 网页标签标题 -->
	<title>dromara(Open source organization)</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dromara.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/soul/soul.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>Soul</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/soul.html" target="_self">soul介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/team.html" target="_self">团队介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/induction.html" target="_self">soul极简入门</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/db.html" target="_self">数据库设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/config.html" target="_self">数据配置流程</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/dataSync.html" target="_self">数据同步原理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/soul/metaData.html" target="_self">元数据概念介绍</a></li><li style="height:612px;overflow:hidden" class="menu-item menu-item-level-2"><span>用户使用文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/setup.html" target="_self">搭建soul网关环境</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/user-http.html" target="_self">http用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/user-dubbo.html" target="_self">dubbo用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/user-springcloud.html" target="_self">springCloud用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/selector.html" target="_self">选择器规则详解</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/user-dataSync.html" target="_self">数据同步策略</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-divide.html" target="_self">divide插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-dubbo.html" target="_self">dubbo插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-springcloud.html" target="_self">springcloud插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-rateLimiter.html" target="_self">rateLimiter插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-hystrix.html" target="_self">hystrix插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-monitor.html" target="_self">monitor插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-waf.html" target="_self">waf插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-sign.html" target="_self">sign插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-rewrite.html" target="_self">rewrite插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/plugin-websocket.html" target="_self">websocket支持</a></li></ul></li><li style="height:360px;overflow:hidden" class="menu-item menu-item-level-2"><span>开发者文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-filter.html" target="_self">自定义filter</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-plugin.html" target="_self">自定义插件</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-file.html" target="_self">文件上传下载</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-iphost.html" target="_self">自定义解析IP与host</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-result.html" target="_self">自定义返回结果</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-sign.html" target="_self">自定义签名插件算法与验证</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-client.html" target="_self">多语言http客户端接入</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-thread.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/soul/dev-netty.html" target="_self">soul调优</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>Hmily</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/index.html" target="_self">介绍文档</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/term.html" target="_self">术语</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/team.html" target="_self">团队介绍</a></li><li style="height:216px;overflow:hidden" class="menu-item menu-item-level-2"><span>配置模块<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/config.html" target="_self">配置详解</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/config-local.html" target="_self">本地模式</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/config-zookeeper.html" target="_self">zookeeper配置中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/config-nacos.html" target="_self">nacos配置中心</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/config-apollo.html" target="_self">apollo配置中心</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/annotation.html" target="_self">注解详解</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/context.html" target="_self">事务上下文</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/metrics.html" target="_self">metrics信息</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/tcc.html" target="_self">TCC模式</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/hmily/tac.html" target="_self">TAC模式</a></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>用户文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/user-dubbo.html" target="_self">dubbo用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/user-motan.html" target="_self">motan用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/user-springcloud.html" target="_self">springcloud用户</a></li></ul></li><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>快速体验<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/quick-start-dubbo.html" target="_self">quick-start-dubbo</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/quick-start-springcloud.html" target="_self">quick-start-springcloud</a></li></ul></li><li style="height:72px;overflow:hidden" class="menu-item menu-item-level-2"><span>运维平台<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/hmily/admin.html" target="_self">启动admin</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>raincat</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/raincat/index.html" target="_self">介绍文档</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/raincat/start-manager.html" target="_self">启动raincat-manager</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/raincat/config.html" target="_self">配置详解</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/raincat/admin.html" target="_self">启动admin</a></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>用户文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/raincat/user-dubbo.html" target="_self">dubbo用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/raincat/user-motan.html" target="_self">motan用户</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/raincat/user-springcloud.html" target="_self">springcloud用户</a></li></ul></li><li style="height:108px;overflow:hidden" class="menu-item menu-item-level-2"><span>快速体验<img style="transform:rotate(0deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/raincat/quick-start-dubbo.html" target="_self">quick-start-dubbo</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/raincat/quick-start-springcloud.html" target="_self">quick-start-springcloud</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>myth</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/myth/index.html" target="_self">介绍文档</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h2>说明</h2>
<ul>
<li>本篇主要讲解数据库同步的三种方式，以及原理</li>
</ul>
<h1>前言</h1>
<p>网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，<code>Soul</code> 网关又是如何支持动态配置的呢?</p>
<p>使用过 <code>Soul</code> 的同学都知道，<code>Soul</code> 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 <code>Soul</code> 网关过程中，用户也反馈了不少问题</p>
<ul>
<li>依赖 <code>zookeeper</code>，这让使用 <code>etcd</code>、<code>consul</code>、<code>nacos</code> 注册中心的用户很是困扰</li>
<li>依赖 <code>redis</code>、<code>influxdb</code>，我还没有使用限流插件、监控插件，为什么需要这些</li>
</ul>
<p>因此，我们对 <code>Soul</code> 进行了局部重构，历时两个月的版本迭代，我们发布了 <code>2.0</code> 版本</p>
<ul>
<li>数据同步方式移除了对 <code>zookeeper</code> 的强依赖，新增 <code>http 长轮询</code> 以及 <code>websocket</code></li>
<li>限流插件与监控插件实现真正的动态配置，由之前的 <code>yml</code> 配置，改为 <code>admin</code> 后台用户动态配置</li>
</ul>
<h5>1.可能有人会问我，配置同步为什么不使用配置中心呢？</h5>
<p>答：首先，引入配置中心，会增加很多额外的成本，不管是运维，而且会让 <code>Soul</code> 变得很重；另外，使用配置中心，数据格式不可控，不便于 <code>soul-admin</code> 进行配置管理。</p>
<h5>2.可能还有人会问？动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？</h5>
<p>答：soul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。</p>
<h1>原理分析</h1>
<p>先来张高清无码图，下图展示了 <code>Soul</code> 数据同步的流程，<code>Soul</code> 网关在启动时，会从从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 <code>Soul</code> 网关，具体是 <code>push</code> 模式，还是 <code>pull</code> 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。
<img src="https://bestkobe.gitee.io/images/soul/soul-config-processor.png?_t=201908032316" alt="Soul数据同步流程图"></p>
<p>在 <code>1.x</code> 版本中，配置服务依赖 <code>zookeeper</code> 实现，管理后台将变更信息 <code>push</code> 给网关。而 <code>2.x</code> 版本支持 <code>webosocket</code>、<code>http</code>、<code>zookeeper</code>，通过 <code>soul.sync.strategy</code> 指定对应的同步策略，默认使用 <code>http</code> 长轮询同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，<code>soul-web</code> 和 <code>soul-admin</code> 必须使用相同的同步机制。</p>
<p>如下图所示，<code>soul-admin</code> 在用户发生配置变更之后，会通过 <code>EventPublisher</code> 发出配置变更通知，由 <code>EventDispatcher</code> 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器</p>
<ul>
<li>如果是 <code>websocket</code> 同步策略，则将变更后的数据主动推送给 <code>soul-web</code>，并且在网关层，会有对应的 <code>WebsocketCacheHandler</code> 处理器处理来处 <code>admin</code> 的数据推送</li>
<li>如果是 <code>zookeeper</code> 同步策略，将变更数据更新到 <code>zookeeper</code>，而 <code>ZookeeperSyncCache</code> 会监听到 <code>zookeeper</code> 的数据变更，并予以处理</li>
<li>如果是 <code>http</code> 同步策略，<code>soul-web</code> 主动发起长轮询请求，默认有 90s 超时时间，如果 <code>soul-admin</code> 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求
<img src="https://bestkobe.gitee.io/images/soul/config-strage-processor.png?_t=201908032339" alt="Soul配置同步策略流程图"></li>
</ul>
<h2>zookeeper同步</h2>
<p>基于 zookeeper 的同步原理很简单，主要是依赖 <code>zookeeper</code> 的 watch 机制，<code>soul-web</code> 会监听配置的节点，<code>soul-admin</code> 在启动的时候，会将数据全量写入 <code>zookeeper</code>，后续数据发生变更时，会增量更新 <code>zookeeper</code> 的节点，与此同时，<code>soul-web</code> 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。</p>
<p><img src="https://yu199195.github.io/images/soul/soul-zookeeper.png" alt="zookeeper节点设计"></p>
<p><code>soul</code> 将配置信息写到zookeeper节点，是通过精细设计的。</p>
<h2>websocket同步</h2>
<p><code>websocket</code> 和 <code>zookeeper</code> 机制有点类似，将网关与 <code>admin</code> 建立好 <code>websocket</code> 连接时，<code>admin</code> 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 <code>websocket</code> 主动推送给 <code>soul-web</code></p>
<p>使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。<code>soul</code>使用<code>java-websocket</code> 这个第三方库来进行<code>websocket</code>连接。</p>
<pre><code>public class WebsocketSyncCache extends WebsocketCacheHandler {
    /**
     * The Client.
     */
    private WebSocketClient client;

    public WebsocketSyncCache(final SoulConfig.WebsocketConfig websocketConfig) {
        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1,
                SoulThreadFactory.create(&quot;websocket-connect&quot;, true));
         client = new WebSocketClient(new URI(websocketConfig.getUrl())) {
                @Override
                public void onOpen(final ServerHandshake serverHandshake) {
                  //....
                }
                @Override
                public void onMessage(final String result) {
                  //....
                }    
            };
        //进行连接
        client.connectBlocking();
        //使用调度线程池进行断线重连，30秒进行一次
        executor.scheduleAtFixedRate(() -&gt; {
            if (client != null &amp;&amp; client.isClosed()) {
                    client.reconnectBlocking();
            }
        }, 10, 30, TimeUnit.SECONDS);
    }
</code></pre>
<h2>http长轮询</h2>
<p>zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 <code>Apollo</code>、<code>Nacos</code> 的设计思想，取决精华，自己实现了 <code>http</code> 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！</p>
<p><img src="https://bestkobe.gitee.io/images/soul/http-long-polling.png?_t=201908032339" alt="http长轮询"></p>
<p>http 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多会等待 90s，这样便于 admin 配置服务及时响应变更数据，从而实现准实时推送。</p>
<p>http 请求到达 sou-admin 之后，并非立马响应数据，而是利用 Servlet3.0 的异步机制，异步响应数据。首先，将长轮询请求任务 <code>LongPollingClient</code> 扔到 <code>BlocingQueue</code> 中，并且开启调度任务，60s 后执行，这样做的目的是 60s 后将该长轮询请求移除队列，即便是这段时间内没有发生配置数据变更。因为即便是没有配置变更，也得让网关知道，总不能让其干等吧，而且网关请求配置服务时，也有 90s 的超时时间。</p>
<pre><code>public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {
    // 因为soul-web可能未收到某个配置变更的通知，因此MD5值可能不一致，则立即响应
    List&lt;ConfigGroupEnum&gt; changedGroup = compareMD5(request);
    String clientIp = getRemoteIp(request);
    if (CollectionUtils.isNotEmpty(changedGroup)) {
        this.generateResponse(response, changedGroup);
        return;
    }

    // Servlet3.0异步响应http请求
    final AsyncContext asyncContext = request.startAsync();
    asyncContext.setTimeout(0L);
    scheduler.execute(new LongPollingClient(asyncContext, clientIp, 60));
}
    
class LongPollingClient implements Runnable {
    LongPollingClient(final AsyncContext ac, final String ip, final long timeoutTime) {
        // 省略......
    }
    @Override
    public void run() {
        // 加入定时任务，如果60s之内没有配置变更，则60s后执行，响应http请求
        this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {
            // clients是阻塞队列，保存了来处soul-web的请求信息
            clients.remove(LongPollingClient.this);
            List&lt;ConfigGroupEnum&gt; changedGroups = HttpLongPollingDataChangedListener.compareMD5((HttpServletRequest) asyncContext.getRequest());
            sendResponse(changedGroups);
        }, timeoutTime, TimeUnit.MILLISECONDS);
        // 
        clients.add(this);
    }
}
</code></pre>
<p>如果这段时间内，管理员变更了配置数据，此时，会挨个移除队列中的长轮询请求，并响应数据，告知是哪个 Group 的数据发生了变更（我们将插件、规则、流量配置、用户配置数据分成不同的组）。网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。有人会问，为什么不是直接将变更的数据写出？我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</p>
<pre><code>// soul-admin发生了配置变更，挨个将队列中的请求移除，并予以响应
class DataChangeTask implements Runnable {
    DataChangeTask(final ConfigGroupEnum groupKey) {
        this.groupKey = groupKey;
    }
    @Override
    public void run() {
        try {
            for (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext(); ) {
                LongPollingClient client = iter.next();
                iter.remove();
                client.sendResponse(Collections.singletonList(groupKey));
            }
        } catch (Throwable e) {
            LOGGER.error(&quot;data change error.&quot;, e);
        }
    }
}
</code></pre>
<p>当 <code>soul-web</code> 网关层接收到 http 响应信息之后，拉取变更信息（如果有变更的话），然后再次请求 <code>soul-admin</code> 的配置服务，如此反复循环。</p>
<h2>仓库地址</h2>
<p>github: <a href="https://github.com/Dromara/soul">https://github.com/Dromara/soul</a></p>
<p>gitee:  <a href="https://gitee.com/shuaiqiyu/soul">https://gitee.com/shuaiqiyu/soul</a></p>
<p>项目主页上还有视频教程，有需要的朋友可以去观看。</p>
<h2>最后</h2>
<p>此文介绍了<code>soul</code>作为一个高可用的微服务网关，为了优化响应速度，在对配置规则选择器器数据进行本地缓存的三种方式，学了此文，我相信你对现在比较流行的配置中心有了一定的了解，看他们的代码也许会变得容易，我相信你也可以自己写一个分布式配置中心出来。3.0版本已经在规划中，肯定会给大家带来惊喜。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/dromara.png"/><div class="cols-container"><div class="col col-12"><h3>免责声明</h3><p>任何单位或个人转载本网站的所有相关信息，请注明来源。</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/soul/soul.html" target="_self">概览</a></dd><dd><a href="/zh-cn/docs/soul/soul.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/soul/soul.html" target="_self">开发者指南</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright ©2018 549477611@qq.com by xiaoyu</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>