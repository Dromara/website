<!DOCTYPE html>
<html lang="zh">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="dromara.org" />
	<meta name="description" content="dromara.org" />
	<!-- 网页标签标题 -->
	<title>dromara(Open source organization)</title>
	<link rel="shortcut icon" href="/website/img/docsite.ico"/>
	<link rel="stylesheet" href="/website/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/website/zh-cn/index.html"><img class="logo" src="/website/img/dromara.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/website/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/website/zh-cn/index.html" target="_self">首页</a><div class="sub-menu"><ul></ul></div></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="#">文档</a><div class="sub-menu"><ul><li><a href="/website/zh-cn/docs/soul/soul.html" target="_self">Soul</a></li><li><a href="/website/zh-cn/docs/hmily/index.html" target="_self">Hmily</a></li></ul></div></li><li class="menu-item menu-item-normal"><a href="/website/zh-cn/blog/index.html" target="_self">博客</a><div class="sub-menu"><ul></ul></div></li><li class="menu-item menu-item-normal"><a href="/website/zh-cn/community/index.html" target="_self">社区</a><div class="sub-menu"><ul></ul></div></li></ul></div></div></header><section class="content-section"><div class="sidemenu" id="menu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>Soul</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/soul.html" target="_self">soul介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/team.html" target="_self">团队介绍</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/induction.html" target="_self">soul极简入门</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/db.html" target="_self">数据库设计</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/config.html" target="_self">数据配置流程</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/dataSync.html" target="_self">数据同步原理</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/website/zh-cn/docs/soul/metaData.html" target="_self">元数据概念介绍</a></li><li style="height:612px;overflow:hidden" class="menu-item menu-item-level-2"><span>用户使用文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/website/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/setup.html" target="_self">搭建soul网关环境</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/user-http.html" target="_self">http用户</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/user-dubbo.html" target="_self">dubbo用户</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/user-springcloud.html" target="_self">springCloud用户</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/selector.html" target="_self">选择器规则详解</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/user-dataSync.html" target="_self">数据同步策略</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-divide.html" target="_self">divide插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-dubbo.html" target="_self">dubbo插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-springcloud.html" target="_self">springcloud插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-rateLimiter.html" target="_self">rateLimiter插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-hystrix.html" target="_self">hystrix插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-monitor.html" target="_self">monitor插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-waf.html" target="_self">waf插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-sign.html" target="_self">sign插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-rewrite.html" target="_self">rewrite插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/plugin-websocket.html" target="_self">websocket支持</a></li></ul></li><li style="height:360px;overflow:hidden" class="menu-item menu-item-level-2"><span>开发者文档<img style="transform:rotate(0deg)" class="menu-toggle" src="/website/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-filter.html" target="_self">自定义filter</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-plugin.html" target="_self">自定义插件</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-file.html" target="_self">文件上传下载</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-iphost.html" target="_self">自定义解析IP与host</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-result.html" target="_self">自定义返回结果</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-sign.html" target="_self">自定义签名插件算法与验证</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-client.html" target="_self">多语言http客户端接入</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-thread.html" target="_self">线程模型</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/dev-netty.html" target="_self">soul调优</a></li></ul></li><li style="height:144px;overflow:hidden" class="menu-item menu-item-level-2"><span>社区贡献<img style="transform:rotate(0deg)" class="menu-toggle" src="/website/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/contributor.html" target="_self">贡献者指南</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/committer.html" target="_self">提交者指南</a></li><li class="menu-item menu-item-level-3"><a href="/website/zh-cn/docs/soul/code-conduct.html" target="_self">编码规范</a></li></ul></li></ul></li></ul></div><div class="doc-content markdown-body" id="doc-body"><h2>说明</h2>
<ul>
<li>本篇主要讲解数据库同步的三种方式，以及原理</li>
</ul>
<h1>前言</h1>
<p>网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，<code>Soul</code> 网关又是如何支持动态配置的呢?</p>
<p>使用过 <code>Soul</code> 的同学都知道，<code>Soul</code> 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 <code>Soul</code> 网关过程中，用户也反馈了不少问题</p>
<ul>
<li>依赖 <code>zookeeper</code>，这让使用 <code>etcd</code>、<code>consul</code>、<code>nacos</code> 注册中心的用户很是困扰</li>
<li>依赖 <code>redis</code>、<code>influxdb</code>，我还没有使用限流插件、监控插件，为什么需要这些</li>
</ul>
<p>因此，我们对 <code>Soul</code> 进行了局部重构，历时两个月的版本迭代，我们发布了 <code>2.0</code> 版本</p>
<ul>
<li>数据同步方式移除了对 <code>zookeeper</code> 的强依赖，新增 <code>http 长轮询</code> 以及 <code>websocket</code></li>
<li>限流插件与监控插件实现真正的动态配置，由之前的 <code>yml</code> 配置，改为 <code>admin</code> 后台用户动态配置</li>
</ul>
<h5>1.可能有人会问我，配置同步为什么不使用配置中心呢？</h5>
<p>答：首先，引入配置中心，会增加很多额外的成本，不光是运维，而且会让 <code>Soul</code> 变得很重；另外，使用配置中心，数据格式不可控，不便于 <code>soul-admin</code> 进行配置管理。</p>
<h5>2.可能还有人会问？动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？</h5>
<p>答：soul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。</p>
<h1>原理分析</h1>
<p>先来张高清无码图，下图展示了 <code>Soul</code> 数据同步的流程，<code>Soul</code> 网关在启动时，会从从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 <code>Soul</code> 网关，具体是 <code>push</code> 模式，还是 <code>pull</code> 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。
<img src="https://bestkobe.gitee.io/images/soul/soul-config-processor.png?_t=201908032316" alt="Soul数据同步流程图"></p>
<p>在 <code>1.x</code> 版本中，配置服务依赖 <code>zookeeper</code> 实现，管理后台将变更信息 <code>push</code> 给网关。而 <code>2.x</code> 版本支持 <code>webosocket</code>、<code>http</code>、<code>zookeeper</code>，通过 <code>soul.sync.strategy</code> 指定对应的同步策略，默认使用 <code>http</code> 长轮询同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，<code>soul-web</code> 和 <code>soul-admin</code> 必须使用相同的同步机制。</p>
<p>如下图所示，<code>soul-admin</code> 在用户发生配置变更之后，会通过 <code>EventPublisher</code> 发出配置变更通知，由 <code>EventDispatcher</code> 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器</p>
<ul>
<li>如果是 <code>websocket</code> 同步策略，则将变更后的数据主动推送给 <code>soul-web</code>，并且在网关层，会有对应的 <code>WebsocketCacheHandler</code> 处理器处理来处 <code>admin</code> 的数据推送</li>
<li>如果是 <code>zookeeper</code> 同步策略，将变更数据更新到 <code>zookeeper</code>，而 <code>ZookeeperSyncCache</code> 会监听到 <code>zookeeper</code> 的数据变更，并予以处理</li>
<li>如果是 <code>http</code> 同步策略，<code>soul-web</code> 主动发起长轮询请求，默认有 90s 超时时间，如果 <code>soul-admin</code> 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求
<img src="https://bestkobe.gitee.io/images/soul/config-strage-processor.png?_t=201908032339" alt="Soul配置同步策略流程图"></li>
</ul>
<h2>zookeeper同步</h2>
<p>基于 zookeeper 的同步原理很简单，主要是依赖 <code>zookeeper</code> 的 watch 机制，<code>soul-web</code> 会监听配置的节点，<code>soul-admin</code> 在启动的时候，会将数据全量写入 <code>zookeeper</code>，后续数据发生变更时，会增量更新 <code>zookeeper</code> 的节点，与此同时，<code>soul-web</code> 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。</p>
<p><img src="https://yu199195.github.io/images/soul/soul-zookeeper.png" alt="zookeeper节点设计"></p>
<p><code>soul</code> 将配置信息写到zookeeper节点，是通过精细设计的。</p>
<h2>websocket同步</h2>
<p><code>websocket</code> 和 <code>zookeeper</code> 机制有点类似，将网关与 <code>admin</code> 建立好 <code>websocket</code> 连接时，<code>admin</code> 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 <code>websocket</code> 主动推送给 <code>soul-web</code></p>
<p>使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。<code>soul</code>使用<code>java-websocket</code> 这个第三方库来进行<code>websocket</code>连接。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsocketSyncCache</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebsocketCacheHandler</span> </span>{
    <span class="hljs-comment">/**
     * The Client.
     */</span>
    <span class="hljs-keyword">private</span> WebSocketClient client;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebsocketSyncCache</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SoulConfig.WebsocketConfig websocketConfig)</span> </span>{
        ScheduledThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(<span class="hljs-number">1</span>,
                SoulThreadFactory.create(<span class="hljs-string">"websocket-connect"</span>, <span class="hljs-keyword">true</span>));
         client = <span class="hljs-keyword">new</span> WebSocketClient(<span class="hljs-keyword">new</span> URI(websocketConfig.getUrl())) {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ServerHandshake serverHandshake)</span> </span>{
                  <span class="hljs-comment">//....</span>
                }
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String result)</span> </span>{
                  <span class="hljs-comment">//....</span>
                }
            };
        <span class="hljs-comment">//进行连接</span>
        client.connectBlocking();
        <span class="hljs-comment">//使用调度线程池进行断线重连，30秒进行一次</span>
        executor.scheduleAtFixedRate(() -&gt; {
            <span class="hljs-keyword">if</span> (client != <span class="hljs-keyword">null</span> &amp;&amp; client.isClosed()) {
                    client.reconnectBlocking();
            }
        }, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);
    }
</code></pre>
<h2>http长轮询</h2>
<p>zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 <code>Apollo</code>、<code>Nacos</code> 的设计思想，取其精华，自己实现了 <code>http</code> 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！</p>
<p><img src="https://bestkobe.gitee.io/images/soul/http-long-polling.png?_t=201908032339" alt="http长轮询"></p>
<p>http 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多会等待 90s，这样便于 admin 配置服务及时响应变更数据，从而实现准实时推送。</p>
<p>http 请求到达 sou-admin 之后，并非立马响应数据，而是利用 Servlet3.0 的异步机制，异步响应数据。首先，将长轮询请求任务 <code>LongPollingClient</code> 扔到 <code>BlocingQueue</code> 中，并且开启调度任务，60s 后执行，这样做的目的是 60s 后将该长轮询请求移除队列，即便是这段时间内没有发生配置数据变更。因为即便是没有配置变更，也得让网关知道，总不能让其干等吧，而且网关请求配置服务时，也有 90s 的超时时间。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLongPolling</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpServletRequest request, <span class="hljs-keyword">final</span> HttpServletResponse response)</span> </span>{
    <span class="hljs-comment">// 因为soul-web可能未收到某个配置变更的通知，因此MD5值可能不一致，则立即响应</span>
    List&lt;ConfigGroupEnum&gt; changedGroup = compareMD5(request);
    String clientIp = getRemoteIp(request);
    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(changedGroup)) {
        <span class="hljs-keyword">this</span>.generateResponse(response, changedGroup);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Servlet3.0异步响应http请求</span>
    <span class="hljs-keyword">final</span> AsyncContext asyncContext = request.startAsync();
    asyncContext.setTimeout(<span class="hljs-number">0L</span>);
    scheduler.execute(<span class="hljs-keyword">new</span> LongPollingClient(asyncContext, clientIp, <span class="hljs-number">60</span>));
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongPollingClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    LongPollingClient(<span class="hljs-keyword">final</span> AsyncContext ac, <span class="hljs-keyword">final</span> String ip, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timeoutTime) {
        <span class="hljs-comment">// 省略......</span>
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 加入定时任务，如果60s之内没有配置变更，则60s后执行，响应http请求</span>
        <span class="hljs-keyword">this</span>.asyncTimeoutFuture = scheduler.schedule(() -&gt; {
            <span class="hljs-comment">// clients是阻塞队列，保存了来自soul-web的请求信息</span>
            clients.remove(LongPollingClient.<span class="hljs-keyword">this</span>);
            List&lt;ConfigGroupEnum&gt; changedGroups = HttpLongPollingDataChangedListener.compareMD5((HttpServletRequest) asyncContext.getRequest());
            sendResponse(changedGroups);
        }, timeoutTime, TimeUnit.MILLISECONDS);
        <span class="hljs-comment">//</span>
        clients.add(<span class="hljs-keyword">this</span>);
    }
}
</code></pre>
<p>如果这段时间内，管理员变更了配置数据，此时，会挨个移除队列中的长轮询请求，并响应数据，告知是哪个 Group 的数据发生了变更（我们将插件、规则、流量配置、用户配置数据分成不同的组）。网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。有人会问，为什么不是直接将变更的数据写出？我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</p>
<pre><code class="language-java"><span class="hljs-comment">// soul-admin发生了配置变更，挨个将队列中的请求移除，并予以响应</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataChangeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    DataChangeTask(<span class="hljs-keyword">final</span> ConfigGroupEnum groupKey) {
        <span class="hljs-keyword">this</span>.groupKey = groupKey;
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext(); ) {
                LongPollingClient client = iter.next();
                iter.remove();
                client.sendResponse(Collections.singletonList(groupKey));
            }
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            LOGGER.error(<span class="hljs-string">"data change error."</span>, e);
        }
    }
}
</code></pre>
<p>当 <code>soul-web</code> 网关层接收到 http 响应信息之后，拉取变更信息（如果有变更的话），然后再次请求 <code>soul-admin</code> 的配置服务，如此反复循环。</p>
<h2>仓库地址</h2>
<p>github: <a href="https://github.com/Dromara/soul">https://github.com/Dromara/soul</a></p>
<p>gitee:  <a href="https://gitee.com/shuaiqiyu/soul">https://gitee.com/shuaiqiyu/soul</a></p>
<p>项目主页上还有视频教程，有需要的朋友可以去观看。</p>
<h2>最后</h2>
<p>此文介绍了<code>soul</code>作为一个高可用的微服务网关，为了优化响应速度，在对配置规则选择器器数据进行本地缓存的三种方式，学了此文，我相信你对现在比较流行的配置中心有了一定的了解，看他们的代码也许会变得容易，我相信你也可以自己写一个分布式配置中心出来。3.0版本已经在规划中，肯定会给大家带来惊喜。</p>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/website/img/dromara.png"/><div class="cols-container"><div class="col col-12"><h3>免责声明</h3><p>任何单位或个人转载本网站的所有相关信息，请注明来源。</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/website/zh-cn/docs/soul/soul.html" target="_self">概览</a></dd><dd><a href="/website/zh-cn/docs/soul/soul.html" target="_self">快速开始</a></dd><dd><a href="/website/zh-cn/docs/soul/soul.html" target="_self">开发者指南</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/website/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/website/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright ©2020 xiaoyu@apache.org by xiaoyu</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '/website';
  </script>
	<script src="/website/build/documentation.js"></script>
</body>
</html>