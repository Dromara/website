{
  "filename": "sign.md",
  "__html": "<ul>\n<li>\n<p>sign是用来检验访问是否有效的前置插件，它会根据请求参数中的，timestamp,module,method,rpcType 4个字段做Key，Value值的拼接，\n再拼接上appSecret，再进行MD5加密生成一个签名，然后对比，来检测请求是否合法。</p>\n</li>\n<li>\n<p>签名算法如下：</p>\n<ul>\n<li>\n<p>首先构造一个Map</p>\n<pre><code class=\"language-java\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Map&lt;String, String&gt; <span class=\"hljs-title\">buildParamsMap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> RequestDTO dto)</span> </span>{\n    Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(<span class=\"hljs-number\">4</span>);\n    map.put(<span class=\"hljs-string\">\"timestamp\"</span>, dto.getTimestamp());\n    map.put(<span class=\"hljs-string\">\"module\"</span>, dto.getModule());\n    map.put(<span class=\"hljs-string\">\"method\"</span>, dto.getMethod());\n    map.put(<span class=\"hljs-string\">\"rpcType\"</span>, dto.getRpcType());\n    <span class=\"hljs-keyword\">return</span> map;\n}\n</code></pre>\n</li>\n<li>\n<p>对Map进行Key的排序后，获取值，再拼装，再拼接appSecret，进行Md5加密，最后转成大写。代码如下：</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">   <span class=\"hljs-comment\">/**\n * acquired sign.\n *\n * <span class=\"hljs-doctag\">@param</span> signKey sign key\n * <span class=\"hljs-doctag\">@param</span> params params\n * <span class=\"hljs-doctag\">@return</span> sign\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">generateSign</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String signKey, <span class=\"hljs-keyword\">final</span> Map&lt;String, String&gt; params)</span> </span>{\n    List&lt;String&gt; storedKeys = Arrays.stream(params.keySet()\n            .toArray(<span class=\"hljs-keyword\">new</span> String[]{}))\n            .sorted(Comparator.naturalOrder())\n            .collect(Collectors.toList());\n    <span class=\"hljs-keyword\">final</span> String sign = storedKeys.stream()\n            .filter(key -&gt; !Objects.equals(key, Constants.SIGN))\n            .map(key -&gt; String.join(<span class=\"hljs-string\">\"\"</span>, key, params.get(key)))\n            .collect(Collectors.joining()).trim()\n            .concat(signKey);\n    <span class=\"hljs-keyword\">return</span> DigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase();\n}\n</code></pre>\n</li>\n<li>\n<p>在soul的admin后台会有一个功能来专门维护appKey和appSecret，appKey的含义对应的就是请求参数中的moudule，appSecret是分配给某一个系统模块的秘钥。前端只需要根据算法得到并传递签名值，和moulde。soul也会进行同样的算法生成签名，来对比，从而检验请求的合法性。</p>\n</li>\n<li>\n<p>如果用户觉得麻烦，不想进行安全性的校验，可以在admin后台把Sign插件停用。</p>\n</li>\n</ul>\n",
  "title": "sign插件",
  "keywords": "sign",
  "description": "sign插件"
}