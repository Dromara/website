{
  "filename": "source-learning-02-http-client-register.md",
  "__html": "<h1>HTTP 用户接入 Soul 网关注册逻辑分析</h1>\n<h2>1. 注册入口</h2>\n<p>HTTP 用户接入 Soul 网关时，会调用 soul-admin 一个接口，把需要 Soul 网关管理的接口注册，今天就具体看看到底干了点儿啥。</p>\n<p>先看下调用的接口信息如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SpringMvcClientBeanPostProcessor.java</span>\n<span class=\"hljs-comment\">/**\n * Instantiates a new Soul client bean post processor.\n *\n * <span class=\"hljs-doctag\">@param</span> soulSpringMvcConfig the soul spring mvc config\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SpringMvcClientBeanPostProcessor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> SoulSpringMvcConfig soulSpringMvcConfig)</span> </span>{\n    ValidateUtils.validate(soulSpringMvcConfig);\n    <span class=\"hljs-keyword\">this</span>.soulSpringMvcConfig = soulSpringMvcConfig;\n    url = soulSpringMvcConfig.getAdminUrl() + <span class=\"hljs-string\">\"/soul-client/springmvc-register\"</span>;\n    executorService = <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;&gt;());\n}\n</code></pre>\n<h2>2. springmvc-register 接口逻辑</h2>\n<p>全局搜索 &quot;springmvc-register&quot;，找到 soul-admin 模块下的 SoulClientController，看到这里，对于经常写 CRUD 的我们是不是很熟悉？哈哈~</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientController.java</span>\n<span class=\"hljs-comment\">/**\n * Register spring mvc string.\n *\n * <span class=\"hljs-doctag\">@param</span> springMvcRegisterDTO the spring mvc register dto\n * <span class=\"hljs-doctag\">@return</span> the string\n */</span>\n<span class=\"hljs-meta\">@PostMapping</span>(<span class=\"hljs-string\">\"/springmvc-register\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">registerSpringMvc</span><span class=\"hljs-params\">(@RequestBody <span class=\"hljs-keyword\">final</span> SpringMvcRegisterDTO springMvcRegisterDTO)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> soulClientRegisterService.registerSpringMvc(springMvcRegisterDTO);\n}\n</code></pre>\n<p>Service 层实现类：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-meta\">@Transactional</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">registerSpringMvc</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> SpringMvcRegisterDTO dto)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (dto.isRegisterMetaData()) {\n        MetaDataDO exist = metaDataMapper.findByPath(dto.getPath());\n        <span class=\"hljs-keyword\">if</span> (Objects.isNull(exist)) {\n            saveSpringMvcMetaData(dto);\n        }\n    }\n    String selectorId = handlerSpringMvcSelector(dto);\n    handlerSpringMvcRule(selectorId, dto);\n    <span class=\"hljs-keyword\">return</span> SoulResultMessage.SUCCESS;\n}\n</code></pre>\n<p>dto.isRegisterMetaData() 这个是否注册元数据信息的判断，不知道什么时候用，存疑 //TODO，先往下走。</p>\n<h3>2.1 先看看这个方法 handlerSpringMvcSelector，处理 Selector。</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">handlerSpringMvcSelector</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> SpringMvcRegisterDTO dto)</span> </span>{\n    String contextPath = dto.getContext();\n    <span class=\"hljs-comment\">// 根据 contextPath 到数据库里查询，是否已经注册过。</span>\n    SelectorDO selectorDO = selectorService.findByName(contextPath);\n    String selectorId;\n    String uri = String.join(<span class=\"hljs-string\">\":\"</span>, dto.getHost(), String.valueOf(dto.getPort()));\n    <span class=\"hljs-keyword\">if</span> (Objects.isNull(selectorDO)) {\n        <span class=\"hljs-comment\">// 还没有注册过</span>\n        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 已经注册过，业务系统重启了会到这里</span>\n        selectorId = selectorDO.getId();\n        <span class=\"hljs-comment\">//update upstream</span>\n        String handle = selectorDO.getHandle();\n        String handleAdd;\n        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);\n        SelectorData selectorData = selectorService.buildByName(contextPath);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(handle)) {\n            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));\n        } <span class=\"hljs-keyword\">else</span> {\n            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n            <span class=\"hljs-keyword\">for</span> (DivideUpstream upstream : exist) {\n                <span class=\"hljs-keyword\">if</span> (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {\n                    <span class=\"hljs-keyword\">return</span> selectorId;\n                }\n            }\n            exist.add(addDivideUpstream);\n            handleAdd = GsonUtils.getInstance().toJson(exist);\n        }\n        selectorDO.setHandle(handleAdd);\n        selectorData.setHandle(handleAdd);\n        <span class=\"hljs-comment\">// update db</span>\n        selectorMapper.updateSelective(selectorDO);\n        <span class=\"hljs-comment\">// submit upstreamCheck</span>\n        upstreamCheckService.submit(contextPath, addDivideUpstream);\n        <span class=\"hljs-comment\">// publish change event.</span>\n        eventPublisher.publishEvent(<span class=\"hljs-keyword\">new</span> DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\n                Collections.singletonList(selectorData)));\n    }\n    <span class=\"hljs-keyword\">return</span> selectorId;\n}\n</code></pre>\n<h4>2.1.1 第一次接入 Soul 网关</h4>\n<p>新接入的，到数据库里肯定查不到 selectorDO，进入 registerSelector 方法，仔细看看到底往哪些数据库表中插数据了。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">registerSelector</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String contextPath, <span class=\"hljs-keyword\">final</span> String rpcType, <span class=\"hljs-keyword\">final</span> String appName, <span class=\"hljs-keyword\">final</span> String uri)</span> </span>{\n    SelectorDTO selectorDTO = SelectorDTO.builder()\n            .name(contextPath)\n            .type(SelectorTypeEnum.CUSTOM_FLOW.getCode())\n            .matchMode(MatchModeEnum.AND.getCode())\n            .enabled(Boolean.TRUE)\n            .loged(Boolean.TRUE)\n            .continued(Boolean.TRUE)\n            .sort(<span class=\"hljs-number\">1</span>)\n            .build();\n    <span class=\"hljs-keyword\">if</span> (RpcTypeEnum.DUBBO.getName().equals(rpcType)) {\n        selectorDTO.setPluginId(getPluginId(PluginEnum.DUBBO.getName()));\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (RpcTypeEnum.SPRING_CLOUD.getName().equals(rpcType)) {\n        selectorDTO.setPluginId(getPluginId(PluginEnum.SPRING_CLOUD.getName()));\n        selectorDTO.setHandle(GsonUtils.getInstance().toJson(buildSpringCloudSelectorHandle(appName)));\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (RpcTypeEnum.SOFA.getName().equals(rpcType)) {\n        selectorDTO.setPluginId(getPluginId(PluginEnum.SOFA.getName()));\n        selectorDTO.setHandle(appName);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (RpcTypeEnum.TARS.getName().equals(rpcType)) {\n        selectorDTO.setPluginId(getPluginId(PluginEnum.TARS.getName()));\n        selectorDTO.setHandle(appName);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">//is divide</span>\n        DivideUpstream divideUpstream = buildDivideUpstream(uri);\n        String handler = GsonUtils.getInstance().toJson(Collections.singletonList(divideUpstream));\n        selectorDTO.setHandle(handler);\n        selectorDTO.setPluginId(getPluginId(PluginEnum.DIVIDE.getName()));\n        upstreamCheckService.submit(selectorDTO.getName(), divideUpstream);\n    }\n    SelectorConditionDTO selectorConditionDTO = <span class=\"hljs-keyword\">new</span> SelectorConditionDTO();\n    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName());\n    selectorConditionDTO.setParamName(<span class=\"hljs-string\">\"/\"</span>);\n    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());\n    selectorConditionDTO.setParamValue(contextPath + <span class=\"hljs-string\">\"/**\"</span>);\n    selectorDTO.setSelectorConditions(Collections.singletonList(selectorConditionDTO));\n    <span class=\"hljs-keyword\">return</span> selectorService.register(selectorDTO);\n}\n</code></pre>\n<p>看到这么多 if else，是不是很兴奋，小伙伴们可以想想怎么优化掉这么多 if else，PR 搞起来  ^ - ^。</p>\n<p>写了这么多，无非是封装 SelectorDTO 对象，最后调用 selectorService.register(selectorDTO) 入库，继续跟进去。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SelectorServiceImpl.java</span>\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">register</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> SelectorDTO selectorDTO)</span> </span>{\n    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\n    List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();\n    <span class=\"hljs-keyword\">if</span> (StringUtils.isEmpty(selectorDTO.getId())) {\n        selectorMapper.insertSelective(selectorDO);\n        selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {\n            selectorConditionDTO.setSelectorId(selectorDO.getId());\n            <span class=\"hljs-comment\">// 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？</span>\n            selectorConditionMapper.insertSelective(SelectorConditionDO\n                    .buildSelectorConditionDO(selectorConditionDTO));\n        });\n    }\n    publishEvent(selectorDO, selectorConditionDTOs);\n    <span class=\"hljs-keyword\">return</span> selectorDO.getId();\n}\n</code></pre>\n<p>看到这里有2条入库方法，分别向 selector 和 selector_condition 表中插入了数据。这里我们先不具体追究表结构及业务意义，后面补上。</p>\n<p>publishEvent 方法，涉及到 ApplicationEventPublisher 接口，是观察者模式的一个实现，发布事件后通过监听器完成后续操作，这里先按下不表，后续单写一篇文章分析。</p>\n<h4>2.1.2 已经接入 Soul 网关</h4>\n<p>就跟盗梦空间似的，我们回退2层梦境，回到插入数据的另一个分支，可以想见，就是，已经接入过 Soul 网关的系统重启，或新节点启动走的逻辑。</p>\n<p>把前面的代码再贴过来：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">handlerSpringMvcSelector</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> SpringMvcRegisterDTO dto)</span> </span>{\n    String contextPath = dto.getContext();\n    <span class=\"hljs-comment\">// 根据 contextPath 到数据库里查询，是否已经注册过。</span>\n    SelectorDO selectorDO = selectorService.findByName(contextPath);\n    String selectorId;\n    String uri = String.join(<span class=\"hljs-string\">\":\"</span>, dto.getHost(), String.valueOf(dto.getPort()));\n    <span class=\"hljs-keyword\">if</span> (Objects.isNull(selectorDO)) {\n        <span class=\"hljs-comment\">// 还没有注册过</span>\n        selectorId = registerSelector(contextPath, dto.getRpcType(), dto.getAppName(), uri);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 已接入的业务系统重启，或新节点启动，会到这里</span>\n        selectorId = selectorDO.getId();\n        <span class=\"hljs-comment\">//update upstream</span>\n        <span class=\"hljs-comment\">// handle 字段存储这个接口真实节点信息，可能存在多台机器需要负载均衡的场景</span>\n        String handle = selectorDO.getHandle();\n        String handleAdd;\n        DivideUpstream addDivideUpstream = buildDivideUpstream(uri);\n        SelectorData selectorData = selectorService.buildByName(contextPath);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(handle)) {\n            <span class=\"hljs-comment\">// 这个接口虽然之前注册过，但第1个服务器节点接入 Soul 时会进来</span>\n            handleAdd = GsonUtils.getInstance().toJson(Collections.singletonList(addDivideUpstream));\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 如果已经至少有1个服务器节点已接入，会进到这里，判断是否是同一个节点（使用 upstreamUrl 区分），如果相同直接返回</span>\n            List&lt;DivideUpstream&gt; exist = GsonUtils.getInstance().fromList(handle, DivideUpstream<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n            <span class=\"hljs-keyword\">for</span> (DivideUpstream upstream : exist) {\n                <span class=\"hljs-keyword\">if</span> (upstream.getUpstreamUrl().equals(addDivideUpstream.getUpstreamUrl())) {\n                    <span class=\"hljs-keyword\">return</span> selectorId;\n                }\n            }\n            <span class=\"hljs-comment\">// 如果不是同一个节点，把新节点加入到 handle 字段中</span>\n            exist.add(addDivideUpstream);\n            handleAdd = GsonUtils.getInstance().toJson(exist);\n        }\n        selectorDO.setHandle(handleAdd);\n        selectorData.setHandle(handleAdd);\n        <span class=\"hljs-comment\">// update db 更新数据库</span>\n        selectorMapper.updateSelective(selectorDO);\n        <span class=\"hljs-comment\">// submit upstreamCheck</span>\n        upstreamCheckService.submit(contextPath, addDivideUpstream);\n        <span class=\"hljs-comment\">// publish change event.</span>\n        eventPublisher.publishEvent(<span class=\"hljs-keyword\">new</span> DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\n                Collections.singletonList(selectorData)));\n    }\n    <span class=\"hljs-keyword\">return</span> selectorId;\n}\n</code></pre>\n<p>因为还没有研究数据库表结构设计，根据已知部分猜测，1个 selector 对应一个 divide 插件，这个插件以 contextPath 为标识（在这里就是 &quot;/http&quot;），一个 contextPath 可以部署多个服务器节点，这些节点信息已 json 形式保存在 handle 字段中。</p>\n<pre><code class=\"language-json\"><span class=\"hljs-comment\">// handle/handleAdd 数据格式</span>\n[\n\t{\n\t\t<span class=\"hljs-attr\">\"upstreamHost\"</span>: <span class=\"hljs-string\">\"localhost\"</span>,\n\t\t<span class=\"hljs-attr\">\"protocol\"</span>: <span class=\"hljs-string\">\"http://\"</span>,\n\t\t<span class=\"hljs-attr\">\"upstreamUrl\"</span>: <span class=\"hljs-string\">\"10.0.0.12:8188\"</span>,\n\t\t<span class=\"hljs-attr\">\"weight\"</span>: <span class=\"hljs-number\">50</span>,\n\t\t<span class=\"hljs-attr\">\"status\"</span>: <span class=\"hljs-literal\">true</span>,\n\t\t<span class=\"hljs-attr\">\"timestamp\"</span>: <span class=\"hljs-number\">0</span>,\n\t\t<span class=\"hljs-attr\">\"warmup\"</span>: <span class=\"hljs-number\">0</span>\n\t}\n]\n</code></pre>\n<p>下面紧接着就是更新数据库 updateSelective。</p>\n<p>upstreamCheckService.submit(contextPath, addDivideUpstream); 把真实服务器节点信息缓存在一个 Map(UPSTREAM_MAP) 里，有定时任务定期探活，如果发现服务节点宕机了，就把他剔除出去，防止把请求发送到已经宕机的节点上。</p>\n<p>然后就是 eventPublisher.publishEvent()，跟前面的 publishEvent 方法一样，发布事件后通过监听器完成后续操作（简单介绍下，这里是通过与 Soul 网关建立的 websocket 长连接发送数据 SelectorData 修改的消息，Soul 网关根据消息修改数据，这个具体改的什么数据，怎么修改的，后面分析）。</p>\n<p>到这里终于把 handlerSpringMvcSelector 这个方法分析完了。</p>\n<h3>2.2 再来看看这个方法 handlerSpringMvcRule，处理 Rule。</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handlerSpringMvcRule</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String selectorId, <span class=\"hljs-keyword\">final</span> SpringMvcRegisterDTO dto)</span> </span>{\n    RuleDO ruleDO = ruleMapper.findByName(dto.getRuleName());\n    <span class=\"hljs-keyword\">if</span> (Objects.isNull(ruleDO)) {\n        registerRule(selectorId, dto.getPath(), dto.getRpcType(), dto.getRuleName());\n    }\n}\n</code></pre>\n<p>首先拿着规则名字，到 rule 表里捞数据，如果捞到了表名已经注册过了，无操作。</p>\n<p>看下数据库数据，就是业务系统下的接口地址。</p>\n<pre><code class=\"language-bash\">mysql&gt; use soul;\nDatabase changed\n\nmysql&gt; select * from rule <span class=\"hljs-built_in\">where</span> name = <span class=\"hljs-string\">'/http/order/findById'</span> \\G\n*************************** 1. row ***************************\n          id: 1349650371868782592\n selector_id: 1349650371302551552\n  match_mode: 0\n        name: /http/order/findById\n     enabled: 1\n       loged: 1\n        sort: 1\n      handle: {<span class=\"hljs-string\">\"loadBalance\"</span>:<span class=\"hljs-string\">\"random\"</span>,<span class=\"hljs-string\">\"retry\"</span>:0,<span class=\"hljs-string\">\"timeout\"</span>:3000}\ndate_created: 2021-01-14 17:31:39\ndate_updated: 2021-01-14 17:31:39\n1 row <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">set</span> (0.00 sec)\n</code></pre>\n<p>如果没捞到数据，注册这个规则。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// SoulClientRegisterServiceImpl.java</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerRule</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String selectorId, <span class=\"hljs-keyword\">final</span> String path, <span class=\"hljs-keyword\">final</span> String rpcType, <span class=\"hljs-keyword\">final</span> String ruleName)</span> </span>{\n    RuleHandle ruleHandle = RuleHandleFactory.ruleHandle(RpcTypeEnum.acquireByName(rpcType), path);\n    RuleDTO ruleDTO = RuleDTO.builder()\n            .selectorId(selectorId)\n            .name(ruleName)\n            .matchMode(MatchModeEnum.AND.getCode())\n            .enabled(Boolean.TRUE)\n            .loged(Boolean.TRUE)\n            .sort(<span class=\"hljs-number\">1</span>)\n            .handle(ruleHandle.toJson())\n            .build();\n    RuleConditionDTO ruleConditionDTO = RuleConditionDTO.builder()\n            .paramType(ParamTypeEnum.URI.getName())\n            .paramName(<span class=\"hljs-string\">\"/\"</span>)\n            .paramValue(path)\n            .build();\n    <span class=\"hljs-keyword\">if</span> (path.indexOf(<span class=\"hljs-string\">\"*\"</span>) &gt; <span class=\"hljs-number\">1</span>) {\n        ruleConditionDTO.setOperator(OperatorEnum.MATCH.getAlias());\n    } <span class=\"hljs-keyword\">else</span> {\n        ruleConditionDTO.setOperator(OperatorEnum.EQ.getAlias());\n    }\n    ruleDTO.setRuleConditions(Collections.singletonList(ruleConditionDTO));\n    ruleService.register(ruleDTO);\n}\n</code></pre>\n<p>第1行，根据 rpcType(&quot;http&quot;) 获取其对应的 RuleHandle，这里，默认内置3种类型，我们这里的是 HTTP，对应 DivideRuleHandle。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// RuleHandleFactory.java</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RuleHandleFactory</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * The RpcType to RuleHandle class map.\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Map&lt;RpcTypeEnum, Class&lt;? extends RuleHandle&gt;&gt; RPC_TYPE_TO_RULE_HANDLE_CLASS = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;();\n\n    <span class=\"hljs-comment\">/**\n     * The default RuleHandle.\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Class&lt;? extends RuleHandle&gt; DEFAULT_RULE_HANDLE = SpringCloudRuleHandle<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span></span>;\n\n    <span class=\"hljs-keyword\">static</span> {\n        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.HTTP, DivideRuleHandle<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.DUBBO, DubboRuleHandle<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n        RPC_TYPE_TO_RULE_HANDLE_CLASS.put(RpcTypeEnum.SOFA, SofaRuleHandle<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Get a RuleHandle object with given rpc type and path.\n     * <span class=\"hljs-doctag\">@param</span> rpcType   rpc type.\n     * <span class=\"hljs-doctag\">@param</span> path      path.\n     * <span class=\"hljs-doctag\">@return</span>          RuleHandle object.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> RuleHandle <span class=\"hljs-title\">ruleHandle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> RpcTypeEnum rpcType, <span class=\"hljs-keyword\">final</span> String path)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (Objects.isNull(rpcType)) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n        Class&lt;? extends RuleHandle&gt; clazz = RPC_TYPE_TO_RULE_HANDLE_CLASS.getOrDefault(rpcType, DEFAULT_RULE_HANDLE);\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> clazz.newInstance().createDefault(path);\n        } <span class=\"hljs-keyword\">catch</span> (InstantiationException | IllegalAccessException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SoulException(\n                    String.format(<span class=\"hljs-string\">\"Init RuleHandle failed with rpc type: %s, rule class: %s, exception: %s\"</span>,\n                            rpcType,\n                            clazz.getSimpleName(),\n                            e.getMessage()));\n        }\n    }\n}\n</code></pre>\n<p>下面构造 RuleDTO 对象，注册规则。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// RuleServiceImpl.java</span>\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">register</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> RuleDTO ruleDTO)</span> </span>{\n    RuleDO ruleDO = RuleDO.buildRuleDO(ruleDTO);\n    List&lt;RuleConditionDTO&gt; ruleConditions = ruleDTO.getRuleConditions();\n    <span class=\"hljs-keyword\">if</span> (StringUtils.isEmpty(ruleDTO.getId())) {\n        ruleMapper.insertSelective(ruleDO);\n        ruleConditions.forEach(ruleConditionDTO -&gt; {\n            ruleConditionDTO.setRuleId(ruleDO.getId());\n            <span class=\"hljs-comment\">// 这里在 for 循环里调用 dao 层插入数据，是不是可以考虑挪出去一次性批量插入？</span>\n            ruleConditionMapper.insertSelective(RuleConditionDO\n                    .buildRuleConditionDO(ruleConditionDTO));\n        });\n    }\n    publishEvent(ruleDO, ruleConditions);\n    <span class=\"hljs-keyword\">return</span> ruleDO.getId();\n}\n</code></pre>\n<p>分别向 rule 和 rule_condition 表中插入数据。</p>\n<p>publishEvent() 方法，通过 websocket 长连接，向 Soul 网关发送 RuleData 数据。</p>\n<h2>3.总结</h2>\n<p>到这里，调用 &quot;/soul-client/springmvc-register&quot; 接口逻辑分析完了，我们总结下：</p>\n<ul>\n<li>处理 selector\n<ul>\n<li>新增或修改 selector、selector_condition 表数据，持久化到 MySQL。</li>\n<li>通过 websocket 向 Soul 网关发送数据改动信息。</li>\n</ul>\n</li>\n<li>处理 rule\n<ul>\n<li>新增或修改 rule、rule_condition 表数据，持久化到 MySQL。</li>\n<li>通过 websocket 向 Soul 网关发送数据改动信息。</li>\n</ul>\n</li>\n</ul>\n<p>其中表结构及字段含义还需进一步学习和研究，websocket 发送给 Soul 网关后，网关做了什么处理也需要后续分析。</p>\n<p>到这里，HTTP 用户接入 Soul 网关注册逻辑就分析完了。</p>\n<p>如果在工作中你有使用网关的需求，或是个人有学习网关的追求，欢迎来跟我一起分析和学习，Soul 网关，你值得拥有。</p>\n",
  "link": "/zh-cn/blog/soul/source-learning-02-http-client-register.html",
  "meta": {}
}