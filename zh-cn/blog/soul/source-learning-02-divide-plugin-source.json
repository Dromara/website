{
  "filename": "source-learning-02-divide-plugin-source.md",
  "__html": "<h1>Divide 插件如何转发http请求</h1>\n<p>先来设想一下，网关如果收到了一个请求http://xxx.com/openapi/appname/order/findById?id=3，那么怎么将请求转发给对应的业务？</p>\n<p>可以想象一下大概是这几个步骤：</p>\n<ul>\n<li>1.解析url</li>\n<li>2.查看配置文件，看这个url是对应于哪个业务线</li>\n<li>3.读配置文件，获取该业务线在网关注册的所有api列表</li>\n<li>4.判断该用户的这个api请求在不在业务的api列表里面</li>\n<li>5.进行相关的鉴权操作（用户AK/SK鉴权、用户Quota/QPS有没有超）</li>\n<li>6.如果网关有负载均衡功能，那么需要获取业务具体给API配置的负载均衡策略</li>\n<li>7.网关向具体的业务API发起请求</li>\n<li>8.网关将收到的业务API的response发送给用户</li>\n</ul>\n<p>这篇笔记主要来学习一下suol网关是怎么转发http请求的。</p>\n<p>先看一下官方文档的相关介绍<a href=\"https://dromara.org/zh-cn/docs/soul/user-http.html\">http用户</a>、<a href=\"https://dromara.org/zh-cn/docs/soul/plugin-divide.html\">Divide插件</a></p>\n<p>官方文档里面介绍到，如果网关需要支持http转发，那么需要在网关的pom里面有以下依赖：</p>\n<pre><code>        &lt;!--if you use http proxy start this--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n            &lt;artifactId&gt;soul-spring-boot-starter-plugin-divide&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.dromara&lt;/groupId&gt;\n            &lt;artifactId&gt;soul-spring-boot-starter-plugin-httpclient&lt;/artifactId&gt;\n            &lt;version&gt;${project.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--if you use http proxy end this--&gt;\n</code></pre>\n<p>那么可以知道http请求的代理与<code>plugin-divide</code>,<code>plugin-httpclient</code>这两个插件有关。</p>\n<h2>插件链</h2>\n<p>官方文档中说到<code>divide</code>这个插件是实现http请求代理的核心，下面看一下<code>soul-plugin/soul-plugin-divide</code>这个模块的代码，可以看到有一个<code>DividePlugin</code>类，继承自<code>AbstractPlugin</code>，而<code>AbstractPlugin</code>实现了<code>SoulPlugin</code>接口</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021011523120836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"DividePlugin的继承关系\"></p>\n<p>可以看到<code>SoulPlugin</code>是<code>DividePlugin</code>的父类，那么猜测一下<code>SoulPlugin</code>是所有插件的父类。全局搜索一下<code>SoulPlugin</code>果然如此，它是诸多插件的父类。</p>\n<p>在全局搜索<code>SoulPlugin</code>的时候，发现<code>soul-web/src/main/java/org/dromara/soul/web/handler</code>里有一个类<code>SoulWebHandler</code>里面有一个属性是<code>List&lt;SoulPlugin&gt;</code>，猜测<code>SoulWebHandler</code>可以操作多个插件。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115230954422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"SoulWebHandler里面有List\"></p>\n<p>看一下<code>SoulWebHandler</code>的继承关系图，发现它是继承了<code>WebHandler</code>，而<code>WebHandler</code>是spring框架里面的一个接口。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2021011523103754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"SoulWebHandler的继承关系图\">\n由于对WebFlux不了解，上网快速搜索了一下WebHandler，得知这是WebFlux里面一个很重要的东西，它提供了一套通用的http请求处理方案。</p>\n<p>而soul网关的源码里面，自己实现了一个实现了<code>WebHandler</code>接口的<code>SoulWebHandler</code>类，无疑是希望框架使用soul实现的这套东西来处理请求。</p>\n<p>在<code>soul-web/src/main/java/org/dromara/soul/web/configuration</code>里的<code>SoulConfiguration</code>类，它在类头上声明了注解<code>@Configuration</code>，表明它是一个配置。<code>SoulConfiguration</code>类里面向spring容器注入了一个名为<code>webHandler</code>的bean，该bean是SoulWebHandler类型的。Application会在启动的时候扫描被<code>@Configuration</code>注解的类，所以通过以下代码，<code>SoulWebHandler</code>就被注入到spring容器中去了。</p>\n<pre><code>    @Bean(&quot;webHandler&quot;)\n    public SoulWebHandler soulWebHandler(final ObjectProvider&lt;List&lt;SoulPlugin&gt;&gt; plugins) {\n        List&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);\n        final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()\n                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());\n        soulPlugins.forEach(soulPlugin -&gt; log.info(&quot;load plugin:[{}] [{}]&quot;, soulPlugin.named(), soulPlugin.getClass().getName()));\n        return new SoulWebHandler(soulPlugins);\n    }\n</code></pre>\n<p>初始化<code>SoulWebHandler</code>的时候，将排好序的插件传入其构造函数中。各个插件都有一个order属性，可以根据这个属性来对插件进行优先级排序。以<code>DividePlugin</code>为例，看下它的order属性是从一个枚举类里面来的。</p>\n<pre><code>    @Override\n    public int getOrder() {\n        return PluginEnum.DIVIDE.getCode();\n    }\n</code></pre>\n<p>而各个插件的order的具体值是在<code>soul-common/src/main/java/org/dromara/soul/common/enums/PluginEnums</code>这个枚举类里面定义的。PluginEnum的code即为各个插件的order。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231323717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"PluginEnum的定义\">\n插件的顺序为：<code>global -&gt; sign -&gt; waf -&gt; rate-limiter -&gt; hystrix -&gt; resilience4j -&gt; divide -&gt; webClient -&gt; …………</code></p>\n<p>每次有一个请求的时候，WebHandler即SoulWebHandler的<code>handle</code>方法都会被调用，该方法里面最主要的就是初始化了一个插件链<code>DefaultSoulPluginChain</code>，并执行该插件链。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231406346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"插件链的初始化\"></p>\n<p>看一下<code>DefaultSoulPluginChain</code>的<code>execute</code>方法，里面遍历所有插件，依次调用插件的<code>execute</code>方法。</p>\n<pre><code>    @Override\n    public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {\n        return Mono.defer(() -&gt; {\n            if (this.index &lt; plugins.size()) {\n                SoulPlugin plugin = plugins.get(this.index++);\n                Boolean skip = plugin.skip(exchange);\n                if (skip) {\n                    return this.execute(exchange);\n                }\n                return plugin.execute(exchange, this);\n            }\n            return Mono.empty();\n        });\n    }\n</code></pre>\n<p>我们看一下<code>DividePlugin</code>的<code>execute</code>方法里面具体做了什么，从源码中看到<code>DividePlugin</code>并没有Override父类的<code>execute</code>方法。所以我们去父类<code>AbstractSoulPlugin</code>里面看一下<code>execute</code>方法具体做了什么。可以从下图看到，获取到了selector和rule，以便执行divide插件的doExecute方法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231447528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"AbstractSoulPlugin的execute\"></p>\n<h2>选择器与规则</h2>\n<p>下面介绍一下<code>选择器（Selector）</code>和<code>规则 (Rule)</code>两个概念。</p>\n<p>官方文档里面介绍到，“选择器相当于是对流量的第一次筛选，规则就是最终的筛选“</p>\n<p>看一下soul-admin管理后台的divide这个tab，可以看到<a href=\"https://blog.csdn.net/pcmmcpmorse/article/details/112646476\">上一篇笔记</a>里面启动的soul-example-http服务的一些API被映射到了选择器和规则里面。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231526336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"soul-admin 管理后台的selector rule\"></p>\n<p>设想一下，你在网上买了东西，填收货地址的时候，大多数的交互都是让你<code>省-&gt;市</code>级联选择，极少数的交互是直接给你一个按首字母索引的全国城市列表来选择。</p>\n<p><code>选择器-&gt;规则</code>类似于是<code>省-&gt;市</code>，http流量到网关的时候，网关先使用<code>选择器</code>来匹配，然后再进一步使用<code>规则</code>来匹配。这样做的好处应该是当网关有几百个下游业务(几万/几十万个API)的时候，可以比较快速地匹配到请求应该被转发的地址。</p>\n<p>一般情况下，可以认为一个spring boot是一个业务，<code>选择器</code>里面可以初步匹配业务的名字，<code>规则</code>可以匹配业务的具体API。例如我有业务A、业务B都售卖API，那么就可以有<code>/businessA</code>、<code>/businessB</code>两个<code>选择器</code>。</p>\n<p>上文提到，一个http请求过来了之后，从缓存里面获取到了与该url匹配的selector和rule，下面看下divide插件是怎么根据selector和rule进行http请求的代理转发的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231612490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"DividePlugin的doExecute方法\"></p>\n<p>从上图中可以看出，DividePlugin从selector和rule中根据负载均衡策略选择并拼装成真正的url，将真正的url和超时时间、重试次数这三个值放到了<code>ServerWebExchange</code>的<code>attribute</code>里面。</p>\n<p>上文在插件链的顺序里面提到，divide的下一个插件是webClient。我们去<code>soul-plugin-httpclient/src/main/java/org/dromara/soul/plugin/httpClient/</code>里面看一下<code>WebClientPlugin</code>的execute方法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210115231640417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BjbW1jcG1vcnNl,size_16,color_FFFFFF,t_70#pic_center\" alt=\"WebClientPlugin的execute方法\"></p>\n<p>可以从上图看到，WebClientPlugin的execute方法里面，从exchange里面取出了HTTP_URL、HTTP_TIME_OUT、HTTP_RETRY，并发送了http请求。至此，一个外部的http请求就被网关真正代理到业务线去了。</p>\n<p>本文就先到此，后续将学习soul网关的其他机制，如果时间富余的话要学习一下WebFlux框架相关的知识。</p>\n",
  "link": "/zh-cn/blog/soul/source-learning-02-divide-plugin-source.html",
  "meta": {}
}